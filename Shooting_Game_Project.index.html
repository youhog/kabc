<!DOCTYPE html>
<html>
    <head>
        <title>Shooting Game Project</title>
        <style>
            canvas {
                background:black;
                display:block;
                margin: 0 auto;
            }
        </style>
    </head>
    <body>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <script>
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            let player = {
                x: 375,
                y: 500,
                width: 50,
                height: 50,
                color: "lightblue",
                velocity: 0
            };

            let keys = {left: false, right: false, space: false};
            let bullets = [];
            let enemies = [];
            let effects = [];

            window.addEventListener("keydown",e=>{
                if(e.key === "ArrowLeft") keys.left = true;
                if(e.key === "ArrowRight") keys.right = true;
                if(e.key === " ") keys.space = true;
            })

            window.addEventListener("keyup",e=>{
                if(e.key === "ArrowLeft") keys.left = false;
                if(e.key === "ArrowRight") keys.right = false;
                if(e.key === " ") keys.space = false;
            });

            function drawPlayer() {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.fillStyle = "lightgray";
                const gunWidth = 10;
                const gunHeight = 20;
                const gunX = player.x + player.width / 2 - gunWidth / 2;
                const gunY = player.y - gunHeight;
                ctx.fillRect(gunX, gunY, gunWidth, gunHeight);
            }

            function drawBullets() {
                ctx.fillStyle = "lime";
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
            }

            function updateBullets() {
                bullets.forEach((bullet, index) => {
                    bullet.y -= bullet.speed;
                    if(bullet.y + bullet.height < 0) {
                        bullets.splice(index, 1);
                    }
                });
            }

            function shootBullet() {
                bullets.push({
                    x: player.x + player.width / 2 - 2.5,
                    y: player.y - 10,
                    width: 5,
                    height: 10,
                    speed: 6
                });
            }

            let canShoot = true;
            function handleShooting() {
                if(keys.space && canShoot) {
                    shootBullet();
                    canShoot = false;
                    setTimeout(() => { canShoot = true; }, 100);
                }
            }

            function spawnEnemy() {
                const strongCount = enemies.filter(e => e.color === "red").length;
                const canSpawnStrong = strongCount < 3;
                const isStrong = Math.random() < 0.3 && canSpawnStrong;
                const width = isStrong ? 60 : 40;
                const height = isStrong ? 60 : 40;
                const color = isStrong ? "red" : "yellow";
                const health = isStrong ? 6 : 3;
                const speed = isStrong ? 0.33 : 1.0;
                enemies.push({
                    x: Math.random() * (canvas.width - width),
                    y: -height,
                    width: width,
                    height: height,
                    color: color,
                    speed: speed,
                    health: health,
                    flash: 0,
                    scale: 1
                });
            }

            function drawEnemies() {
                enemies.forEach(enemy => {
                    ctx.save();
                    const centerX = enemy.x + enemy.width / 2;
                    const centerY = enemy.y + enemy.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.scale(enemy.scale, enemy.scale);
                    ctx.translate(-centerX, -centerY);
                    ctx.fillStyle = enemy.flash > 0 ? "lightgray" : enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    if(enemy.flash > 0) enemy.flash--;
                    ctx.restore();
                    if(enemy.scale > 1) enemy.scale -= 0.05;
                });
            }

            function updateEnemies() {
                enemies.forEach((enemy, index) => {
                    enemy.y += enemy.speed;
                    if(enemy.y > canvas.height) {
                        enemies.splice(index, 1);
                    }
                });
            }

            function drawEffects() {
                effects.forEach((effect, index) => {
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
                    ctx.fill();
                    effect.life--;
                    if(effect.life <= 0) {
                        effects.splice(index, 1);
                    }
                });
            }

            function checkCollisions() {
                bullets.forEach((bullet, bIndex) => {
                    enemies.forEach((enemy, eIndex) => {
                        if(bullet.x < enemy.x + enemy.width &&
                           bullet.x + bullet.width > enemy.x &&
                           bullet.y < enemy.y + enemy.height &&
                           bullet.y + bullet.height > enemy.y) {
                            enemy.health -= 1;
                            bullets.splice(bIndex, 1);
                            enemy.flash = 4;

                            if (enemy.color === "red") {
                                enemy.scale = 1.1;
                            }
                            else {
                                enemy.scale = 1.2;
                            }

                            if(enemy.health <= 0) {
                                effects.push({
                                    x: enemy.x + enemy.width / 2,
                                    y: enemy.y + enemy.height / 2,
                                    radius: 30,
                                    color: "orange",
                                    life: 15
                                });
                                enemies.splice(eIndex, 1);
                            }
                        }
                    });
                });
            }

            function update(){
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const acceleration = 0.5;
                const maxVelocity = 3.5;

                if(keys.left) player.velocity -= acceleration;
                else if(keys.right) player.velocity += acceleration;
                else player.velocity *= 0.8;

                if(player.velocity > maxVelocity) player.velocity = maxVelocity;
                if(player.velocity < -maxVelocity) player.velocity = -maxVelocity;
                
                player.x += player.velocity;
                if(player.x < 0) {player.x = 0; player.velocity = 0;}
                if(player.x + player.width > canvas.width) {player.x = canvas.width - player.width; player.velocity = 0;}

                handleShooting();
                updateBullets();
                updateEnemies();
                checkCollisions();

                drawBullets();
                drawPlayer();
                drawEnemies();
                drawEffects();

                requestAnimationFrame(update);
            }

            setInterval(spawnEnemy, 1500);

            update();

           
        </script>
    </body>
</html>